import edu.wpi.first.gradlerio.frc.FRCPlugin
import edu.wpi.first.toolchain.NativePlatforms

plugins {
    id "java"
    id 'edu.wpi.first.GradleVsCode' version '0.8.0'
    id "edu.wpi.first.GradleRIO" version "2019.3.2"
    id "cpp"
    id "edu.wpi.first.GradleJni" version "0.4.1"
    id "maven-publish"
}

sourceCompatibility = JavaVersion.VERSION_11
targetCompatibility = JavaVersion.VERSION_11

// Maven central needed for JUnit
repositories {
    mavenCentral()
}

group = 'com.github'
version = '1.0'

// Defining my dependencies. In this case, WPILib (+ friends), and vendor libraries.
// Also defines JUnit 4.
dependencies {
    compile wpi.deps.wpilib()
    compile wpi.deps.vendor.java()
    nativeZip wpi.deps.vendor.jni(wpi.platforms.roborio)
    nativeDesktopZip wpi.deps.vendor.jni(wpi.platforms.desktop)
    testCompile 'junit:junit:4.12'
}

// Setting up my Jar File. In this case, adding all libraries into the main jar ('fat jar')
// in order to make them all available at runtime. Also adding the manifest so WPILib
// knows where to look for our Robot Class.
jar {
    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
}

def baseArchiveName = 'vl53l1xroborio'

task headersZip(type: Zip) {
    destinationDir = file("build/zips")
    baseName = baseArchiveName
    classifier = "headers"

    from('src/main/jni/include') {
        into '/'
    }
}
task zipSharedLibrary(type: Zip){
	destinationDir = file("build/zips")
    baseName = baseArchiveName
    classifier = "linuxathenashared" 
    from('build/libs/vl53l1x_i2c/shared/release/') {
        into '/linux/athena/shared'
    }
}
task zipStaticLibrary(type: Zip){
	destinationDir = file("build/zips")
    baseName = baseArchiveName
    classifier = "linuxathenastatic"
    from('build/libs/vl53l1x_i2c/static/release/') {
        into '/linux/athena/static'
    }
}
task zipSharedLibraryDebug(type: Zip){
	destinationDir = file("build/zips")
    baseName = baseArchiveName
    classifier = "linuxathenashareddebug" 
    from('build/libs/vl53l1x_i2c/shared/debug/') {
        into '/linux/athena/shared'
    }
}
task zipStaticLibraryDebug(type: Zip){
	destinationDir = file("build/zips")
    baseName = baseArchiveName
    classifier = "linuxathenastaticdebug"
    from('build/libs/vl53l1x_i2c/static/debug/') {
        into '/linux/athena/static'
    }
}

// Make sure build completes before trying to make a zip of the built libraries
zipSharedLibrary.dependsOn build
zipStaticLibrary.dependsOn build
zipSharedLibraryDebug.dependsOn build
zipStaticLibraryDebug.dependsOn build
headersZip.dependsOn build

def mavenrepo = rootProject.projectDir.toString() + "/build/maven"
def vendordepsdir = rootProject.projectDir.toString() + "/build/vendordeps"
def libVersion = "2019-1"
def publishGroup = 'org.github.warrenlp'

model {
    components {
        vl53l1x_i2c(JniNativeLibrarySpec) { // Use JniNativeLibrarySpec to get a JNI library
            targetPlatform wpi.platforms.roborio
            enableCheckTask true // Set to true to enable a JNI check task. This will search all generated JNI headers, and check to ensure their symbols exist in the native library
            javaCompileTasks << compileJava // set javaCompileTasks to any java compile tasks that contain your JNI classes. It is a list of tasks
            jniCrossCompileOptions << JniCrossCompileOptions(wpi.platforms.roborio)

            binaries.all {
                cppCompiler.args '-g', '-Wall', '-D__LINUX__'
            }

            sources.cpp {
                source {
                    srcDir 'src/main/jni/cpp'
                    include '**/*.cpp', '**/*.c'
                }
                exportedHeaders {
                    srcDir 'src/main/jni/include'
                    if (project.hasProperty('generatedHeaders')) {
                        srcDir generatedHeaders
                    }
                    include '**/*.h'
                }
            }
            // Defining my dependencies. In this case, WPILib (+ friends), and vendor libraries.
            useLibrary(it, "wpilib")
        }
    }

    publishing {
        repositories {
			maven {
				url = mavenrepo
			}
		}

        publications {
            cpp(MavenPublication) {
                artifact zipSharedLibrary
                artifact zipStaticLibrary
                artifact headersZip
                artifact zipSharedLibraryDebug
                artifact zipStaticLibraryDebug
                artifactId = "vl53l1x_i2c_jni"
                groupId publishGroup
                version libVersion
            }
        }
    }
}

// Add the correct version number to the template JSON file and place it in the vendordeps folder to be zipped
task updateJSONVersion()  {
    mkdir vendordepsdir
    def newJSON = new File(vendordepsdir + "/VL53L1X_JNI.json")
    def templateJSON = new File(rootProject.projectDir.toString() + "/VL53L1X_JNI_template.json")

    newJSON.withWriter { def writer ->
        templateJSON.eachLine { def line ->
            def newLine = line.replace("__VERSION_HERE__", '"' + libVersion + '"')
            writer.write(newLine + "\n");
        }
    }
}

// Generate a zip file (with correct directory structure for )
task generateReleaseZip(type: Zip){

    destinationDir = file("build")
    baseName = "vl53l1x_roborio_jni"
    classifier = libVersion
    from(mavenrepo) {
        into 'maven'
    }
    from(vendordepsdir){
        into 'vendordeps'
    }
}

publish.dependsOn updateJSONVersion
publish.dependsOn generateReleaseZip
